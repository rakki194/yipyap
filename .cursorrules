# The `yipyap` Manifesto

---

The frontend of yipyap is built with SolidJS, a reactive JavaScript framework that emphasizes fine-grained reactivity and performance, using Vite as the build tool for fast development and optimized production builds. The application follows a component-based architecture with a central app context managing global state. The main entry point is `/src/main.tsx`, which sets up routing and the app context, while the core application logic resides in `/src/contexts/app.tsx`.

Components are organized in feature-based directories under `/src/components`, each with its own CSS module for styling and `__tests__` directory for component-specific tests. Global styles are defined in `/src/styles.css`, while theme-specific styles are in `/src/themes.css`. The application uses CSS custom properties extensively for theming and maintains a consistent visual hierarchy through shared spacing and color variables.

## The Gallery System

The gallery system is the heart of the application, featuring a sophisticated image viewer with advanced features for image display, navigation, and metadata management. The system is built around several key components:

### Image Viewer Core (`ImageView` Component)

- **Smooth Zooming**: Implements a sophisticated zoom system with:
  - Gradual and smooth zoom transitions (0.001 zoom factor for precision)
  - Cursor-relative zooming that maintains focus point
  - Scale limits (1x to 5x) with smooth interpolation
  - Double-click to reset zoom
  - Zoom level indicator showing current magnification

- **Advanced Panning**:
  - Cursor-aware panning when zoomed
  - Smooth transitions with cubic-bezier easing
  - Grab/grabbing cursor states
  - Edge detection to prevent over-panning
  - Hardware-accelerated transforms for performance

- **Minimap Navigation**:
  - Real-time viewport tracking
  - Interactive navigation by clicking
  - Smooth viewport updates
  - Theme-aware styling with semi-transparent overlay
  - Automatic show/hide based on zoom state
  - Configurable through app settings (`enableMinimap`)

### Image Loading and Display

- **Progressive Loading**:
  - Immediate thumbnail display while loading full preview
  - Smooth opacity transitions between thumbnail and preview
  - Priority-based image loading system
  - Automatic resource cleanup
  - Loading state indicators

- **Performance Optimizations**:
  - Hardware-accelerated transforms
  - Will-change hints for smooth animations
  - Efficient resize handling with ResizeObserver
  - Memory-conscious image unloading
  - Touch action handling for mobile devices

### Tagging System

- **Advanced Color Generation**:
  - OKLCH color space for perceptually uniform colors
  - Theme-aware color generation with specific rules per theme:
    - Dark theme: Low lightness (25%), subtle chroma
    - Light theme: High lightness (85%), subtle chroma
    - Gray theme: Variable lightness, zero chroma
    - Themed variants (banana, strawberry, peanut, christmas, halloween)
  - Deterministic color generation for consistent tag colors
  - Automatic contrast adjustment for text readability

- **Interactive Tag Management**:
  - Keyboard navigation between tags
  - Double-tap detection for quick editing
  - Smooth animations for tag creation/deletion
  - Batch operations support
  - Theme-specific animations and hover effects
  - RTL language support

### Caption Generation

- **Multiple Model Support**:
  - JTP2 and WDv3 model integration
  - Progress tracking with notifications
  - Error handling with user feedback
  - Automatic caption type detection
  - Real-time caption updates

### Accessibility and UX

- **Keyboard Support**:
  - Full keyboard navigation
  - Accessible controls with ARIA labels
  - Focus management
  - Screen reader support

- **Visual Feedback**:
  - Loading indicators
  - Progress notifications
  - Error states
  - Theme-aware animations
  - High contrast support

### Theme Integration

- **Comprehensive Theming**:
  - Theme-specific tag colors and animations
  - Dark/light mode support
  - Special theme variants with unique effects
  - Consistent styling across components
  - Dynamic theme switching
  - RTL layout support

The system is built with performance and extensibility in mind, using SolidJS's fine-grained reactivity for efficient updates and a modular architecture that allows for easy addition of new features and themes.

## Theming System

The application implements a robust theming system with multiple built-in themes (light, dark, gray, strawberry, peanut, christmas, halloween, etc.) that affect not just colors but also animations, visual effects, and component-specific behaviors. Each theme provides custom scrollbar styling, keyboard shortcut visual indicators, and consistent contrast ratios for accessibility. Theme changes are persisted across sessions and can be toggled via keyboard shortcuts or the theme switcher in the settings panel.

The backend is built with FastAPI and follows a modular architecture focused on performance and extensibility. The core functionality is divided into distinct layers: HTTP endpoints (main.py), data access (data_access.py), caption generation (caption_generation/), and utilities (utils.py). The system uses SQLite for caching metadata and thumbnails, with careful attention to cache invalidation and concurrent access patterns.

The caption generation system is particularly noteworthy, implementing a plugin-like architecture where different ML models can be easily integrated. Each caption generator must implement the CaptionGenerator abstract base class, providing a consistent interface while allowing for model-specific optimizations. The system currently supports JTP2 and WDv3 models, with graceful fallback handling if models or dependencies are unavailable.

Maintain consistency with existing code by following established naming conventions and reusing components and styles where appropriate. When writing CSS, ensure compatibility with the global styles defined in `/src/styles.css`.

Theme specific styles are in the `/src/themes.css` file.

There is no `App.tsx` file, do not create it, the root component is in the `/src/main.tsx` file, `/src/contexts/app.tsx` is the app context which is the global state of the app.

Think step-by-step and write code that is easy to understand and maintain.

The translations are in the `/src/i18n` folder, with each language having its own file (e.g., `en.ts`, `ja.ts`, etc.). All language files must follow the type definitions in `/src/i18n/types.ts`, which defines interfaces for different sections of the application (common, settings, frontPage, gallery, tools, etc.). The translation system supports complex pluralization rules through language-specific plural functions (e.g., `getRussianPlural` for Russian's three-form pluralization) and provides type-safe interpolation for dynamic content.

The list of supported languages is defined in `/src/i18n/index.ts` in the `languages` array, which includes language codes and their display names. Each new language must be added to this array. The file also provides helper functions like `getPathSeparator` for platform-specific path separators and `getTranslationValue` for type-safe access to nested translation values. Translations are dynamically imported using Vite's glob imports, allowing for code-splitting and lazy loading of language files. Each translation file exports a default object that implements the `Translations` interface, ensuring type safety across all language implementations.

The system includes RTL (right-to-left) support for languages like Arabic and Hebrew, with automatic text direction switching and appropriate layout adjustments. Translation files can include language-specific formatting rules and custom plural forms, with fallback handling for missing translations.

## Adding New Settings

To add a new setting to the application, follow these steps:

1. Add the setting to the `AppContext` interface in `/src/contexts/app.tsx`:

   ```typescript
   export interface AppContext {
     // ... existing settings ...
     newSetting: boolean; // or appropriate type
     setNewSetting: (value: boolean) => void;
   }
   ```

2. Add the setting to the store type and initial state in `createAppContext`:

   ```typescript
   const [store, setStore] = createStaticStore<{
     // ... existing store properties ...
     newSetting: boolean;
   }>({
     // ... existing initial values ...
     newSetting: localStorage.getItem("newSetting") === "true",
   });
   ```

3. Add a persistence effect to save the setting to localStorage:

   ```typescript
   createRenderEffect(() =>
     localStorage.setItem("newSetting", store.newSetting.toString())
   );
   ```

4. Add the getter and setter to the returned app context:

   ```typescript
   const appContext = {
     // ... existing context properties ...
     get newSetting() {
       return store.newSetting;
     },
     setNewSetting: (value: boolean) => setStore("newSetting", value),
   };
   ```

5. Add the setting to the `SettingsTranslations` interface in `/src/i18n/types.ts`:

   ```typescript
   export interface SettingsTranslations {
     // ... existing translations ...
     newSetting: string;
     newSettingTooltip?: string; // if tooltip is needed
   }
   ```

6. Add the setting UI to the Settings component in `/src/components/Settings/Settings.tsx`:

   ```typescript
   <div class="setting-item">
     <label class="tooltip-container">
       <input
         type="checkbox"
         checked={app.newSetting}
         onChange={(e) => app.setNewSetting(e.currentTarget.checked)}
       />
       {t('settings.newSetting')}
       <span class="tooltip">{t('settings.newSettingTooltip')}</span>
     </label>
   </div>
   ```

7. Add translations for the setting in each language file in `/src/i18n/`:

   ```typescript
   settings: {
     // ... existing translations ...
     newSetting: "New Setting Name",
     newSettingTooltip: "Description of what the setting does",
   }
   ```

If you are refactoring the code, make sure to update the documentation and comments to reflect the changes and also update the `/.cursorrules` file and `/README.md` file accordingly.

## Making Style Changes

To make style changes to the application, follow these steps:

1. Identify the component and its CSS file:
   - Components are in `/src/components/`
   - Each component has its own CSS file (e.g., `/src/components/Gallery/Gallery.css`)
   - Global styles are in `/src/styles.css`
   - Theme-specific styles are in `/src/themes.css`

2. Check for theme variables:
   - Look for CSS variables in `/src/themes.css` that might be relevant
   - Use theme variables (e.g., `var(--accent)`, `var(--text-primary)`) when possible
   - This ensures consistency across all themes

3. Consider the cascading effects:
   - Check if the style affects other components
   - Look for related styles in parent/child components
   - Consider responsive design implications
   - Test the changes across different screen sizes

4. Follow CSS best practices:
   - Use CSS variables for reusable values
   - Keep specificity as low as possible
   - Group related properties together
   - Add comments for complex selectors or calculations
   - Use modern CSS features like `color-mix()` when appropriate
   - Ensure sufficient contrast in all themes
   - Check that animations and transitions work smoothly
   - Verify that the changes respect theme-specific customizations

Example of a style change:

```css
/* Before: Basic selected state */
&.selected {
  background-color: color-mix(in srgb, var(--card-bg) 95%, black);
  backdrop-filter: blur(2px);
}

/* After: Enhanced selected state with theme awareness */
&.selected {
  background-color: color-mix(in srgb, var(--card-bg), var(--text-primary) 80%);
  backdrop-filter: blur(10px);
  box-shadow: 4px 8px 8px rgba(0, 0, 0, 0.4);
  
  & > img {
    filter: brightness(1.1);
  }
}
```

Remember to:
- Document significant style changes in comments
- Update any related documentation
- Consider performance implications of complex CSS properties

## Writing Tests

The project uses Vitest with SolidJS testing utilities. Tests are placed in `__tests__` directories alongside the code they're testing. Each test file should follow the pattern `*.test.ts` or `*.test.tsx`.

### Test Environment Setup

The global test environment is configured in `src/test/setup.ts` and includes:
- DOM environment with jsdom
- Global mocks for browser APIs (matchMedia, ResizeObserver, etc.)
- Automatic cleanup after each test
- SolidJS testing utilities setup

```typescript
import "@testing-library/jest-dom";
import { vi } from "vitest";
import { cleanup } from "@solidjs/testing-library";

beforeAll(() => {
  setupGlobalMocks();
});

afterEach(() => {
  cleanup();
  vi.clearAllMocks();
});
```

### Test Utilities

Common test utilities are provided in `src/test/test-utils.ts` and `src/test/test-hooks.ts`:

1. Standard test wrapper components:

```typescript
export const TestWrapper: Component<{ context: any; children: any }> = (props) => {
  return (
    <AppContext.Provider value={props.context}>
      {props.children}
    </AppContext.Provider>
  );
};
```

2. Test hooks for common setup patterns:

```typescript
export function useBasicTestSetup() {
  beforeEach(() => {
    cleanup();
    vi.clearAllMocks();
  });
}

export function useResourceTestSetup() {
  useBasicTestSetup();
  // Additional resource-specific setup...
}
```

### Component Testing

Component tests should use `@solidjs/testing-library` and follow these patterns:

1. Basic component testing:

```typescript
describe("Component Name", () => {
  it("should render correctly", () => {
    const { container } = render(() => <Component prop={value} />);
    expect(container).toMatchSnapshot();
  });

  it("should handle user interactions", async () => {
    const { getByRole } = render(() => <Component />);
    const button = getByRole("button");
    await fireEvent.click(button);
    expect(result).toBe(expectedValue);
  });
});
```

2. Testing with context:

```typescript
describe("Component with Context", () => {
  const mockContext = {
    // Mock context values...
  };

  it("should use context correctly", () => {
    const { container } = render(() => (
      <TestWrapper context={mockContext}>
        <Component />
      </TestWrapper>
    ));
    // Assertions...
  });
});
```

### Testing Patterns

1. Context Testing:

```typescript
describe("Context Creation", () => {
  test("Context should be defined", () => {
    expect(AppContext).toBeDefined();
    expect(AppContext.id).toBeDefined();
    expect(typeof AppContext.id).toBe("symbol");
  });
});
```

2. Utility Function Testing:

```typescript
describe("Utility Function", () => {
  it("should handle normal input", () => {
    expect(utilityFunction(input)).toBe(expectedOutput);
  });

  it("should handle edge cases", () => {
    expect(utilityFunction(edgeCase)).toBe(expectedOutput);
  });

  it("should throw on invalid input", () => {
    expect(() => utilityFunction(invalidInput)).toThrow();
  });
});
```

3. i18n Testing:

```typescript
describe("Translation System", () => {
  it("should handle pluralization correctly", () => {
    const forms = {
      one: "item",
      few: "items",
      many: "items"
    };
    expect(getPlural(1, forms)).toBe("item");
    expect(getPlural(2, forms)).toBe("items");
  });
});
```

### Mocking

1. API Calls:

```typescript
vi.mock("~/resources/browse", () => ({
  fetchData: vi.fn().mockResolvedValue({ data: "mocked" }),
  saveCaptionToBackend: vi.fn().mockResolvedValue({ success: true })
}));
```

2. Browser APIs:

```typescript
beforeEach(() => {
  Object.defineProperty(window, "matchMedia", {
    value: vi.fn().mockImplementation(query => ({
      matches: false,
      media: query,
      addEventListener: vi.fn(),
      removeEventListener: vi.fn()
    }))
  });
});
```

3. Router:

```typescript
vi.mock("@solidjs/router", () => ({
  useParams: () => ({ path: "test/path" }),
  useSearchParams: () => [{ page: "1" }, vi.fn()],
  useNavigate: () => vi.fn()
}));
```

### Test Documentation

Each test suite should include a JSDoc comment describing:
- Purpose of the test suite
- Key areas being tested
- Test environment setup
- Any special considerations or rules

Example:

```typescript
/**
 * Test suite for the Gallery State Management system.
 * 
 * These tests cover:
 * - Basic state operations
 * - Caption management
 * - Image operations
 * - Navigation and selection
 * 
 * Test Environment Setup:
 * - Mocks router functionality
 * - Mocks backend resources
 * - Mocks window resize observer
 */
```

Remember to:
- Write tests before fixing bugs
- Test edge cases and error conditions
- Keep tests focused and isolated
- Use meaningful test descriptions
- Document complex test setups
- Update tests when modifying functionality

The backend integration is handled through a well-defined API interface, with endpoints for file operations, metadata management, and caption generation. The frontend communicates with these endpoints using typed fetch requests, with proper error handling and loading states. The API interface is defined in TypeScript types shared between the frontend and backend, ensuring type safety across the full stack.

The application includes a comprehensive error handling system with a global error boundary and component-level error states. Errors are displayed through a notification system that supports different severity levels (error, warning, info, success) and can be configured for automatic dismissal. Loading states are managed through SolidJS's resource system, providing a consistent loading experience across the application.

The application's state management is handled through a combination of SolidJS's fine-grained reactivity system and context providers. The app context (`/src/contexts/app.tsx`) manages global settings and theme state, while feature-specific contexts (like the gallery context) handle domain-specific state. All state changes are properly typed and can be persisted to localStorage when appropriate.

## Notifications

The notification system is a sophisticated component-based system that provides temporary user feedback with theme-aware styling, animations, and accessibility features. The system consists of three main components: `NotificationContainer`, `Notification`, and the app context integration.

### Architecture

1. **NotificationContainer Component** (`/src/components/Notification/NotificationContainer.tsx`)
   - Manages the global notification stack
   - Handles notification grouping and positioning
   - Exposes global methods through `window.__notificationContainer`
   - Uses SolidJS signals for reactive state management

2. **Notification Component** (`/src/components/Notification/Notification.tsx`)
   - Handles individual notification rendering and lifecycle
   - Manages animations and interaction states
   - Supports theme-aware styling and icons
   - Implements auto-dismiss and hover behaviors

3. **App Context Integration** (`/src/contexts/app.tsx`)
   - Provides high-level notification API through `app.notify` and `app.createNotification`
   - Handles translation integration
   - Manages notification type defaults and icon mapping

### Usage

#### Basic Notification

```typescript
// Through app context
app.notify("Message", "info");

// With translation key
app.notify("gallery.uploadProgress", "info");

// With all options
app.notify(
  "Processing...",
  "info",
  "upload-group",
  "spinner"
);
```

#### Advanced Usage

```typescript
// Create notification with full control
app.createNotification({
  message: "Custom notification",
  type: "success",
  group: "custom-group",
  icon: "success"
});
```

### Features

1. **Notification Types**
   - `"info"` - Default type with blue styling
   - `"success"` - Green styling for successful operations
   - `"warning"` - Yellow styling for warnings
   - `"error"` - Red styling for errors, persists until dismissed

2. **Icons**
   - `"spinner"` - Animated loading indicator
   - `"success"` - Checkmark icon
   - `"error"` - Error symbol
   - `"info"` - Information icon
   - `"warning"` - Warning symbol
   - Icons automatically match notification type if not specified

3. **Grouping System**
   - Notifications can be grouped using the `group` parameter
   - New notifications in the same group update existing ones
   - Groups maintain stack position for consistent UX
   - Useful for progress updates and related messages

4. **Behavior**
   - Non-error notifications auto-dismiss after 3 seconds
   - Error notifications persist until manually closed
   - Auto-dismiss pauses on hover
   - Close button appears on hover or for error types
   - Smooth enter/exit animations
   - Skip animations for rapid updates in groups

5. **Theme Integration**
   - Uses CSS custom properties for theme-aware colors
   - Supports dark/light mode transitions
   - Consistent with application's theme system
   - Hover effects use `color-mix` for theme-aware interactions

6. **Accessibility**
   - Proper ARIA labels for interactive elements
   - Keyboard navigation support
   - High contrast ratios in all themes
   - Screen reader friendly structure

7. **Translation Support**
   - Integrates with i18n system
   - Automatic message translation
   - Type-safe translation keys
   - Supports interpolation for dynamic content

### Styling

The notification system uses three CSS modules:
- `NotificationContainer.css` - Layout and stacking behavior
- `Notification.css` - Individual notification appearance and animations
- Theme variables from `themes.css` for consistent styling

Example of theme-aware styling:
```css
.notification {
  background-color: var(--card-bg);
  color: var(--text-primary);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.notification.error {
  background-color: var(--error-bg);
  color: var(--error-text);
}
```

### Best Practices

1. **Message Content**
   - Use translation keys for consistent messaging
   - Keep messages concise and clear
   - Include specific details for errors
   - Use proper capitalization and punctuation

2. **Notification Types**
   - Use `"error"` for unrecoverable errors
   - Use `"warning"` for important but non-critical issues
   - Use `"success"` for completed operations
   - Use `"info"` for general updates

3. **Grouping**
   - Group related notifications (e.g., upload progress)
   - Use consistent group names across related operations
   - Clear groups when operations complete

4. **Icons**
   - Use `"spinner"` for ongoing operations
   - Let type-based icons handle standard cases
   - Custom icons only when necessary

### Testing

The notification system includes comprehensive tests:
- Component rendering tests
- Behavior tests (auto-dismiss, hover, etc.)
- Integration tests with app context
- Theme integration tests
- Translation tests
- Group behavior tests

Example test:

```typescript
test("auto-dismisses non-error notifications", () => {
  const onClose = vi.fn();
  render(() => (
    <Notification message="Test" type="info" onClose={onClose} />
  ));
  vi.advanceTimersByTime(3000);
  expect(onClose).toHaveBeenCalled();
});
```

## Common Testing Errors and Solutions

### 1. Timer-Based Test Failures

Location: `src/components/Notification/__tests__/Notification.test.tsx`

```typescript
// Error: Timer-based test failing due to race conditions
test("auto-dismisses after timeout", () => {
  const onClose = vi.fn();
  render(() => <Notification message="Test" type="info" onClose={onClose} />);
  vi.advanceTimersByTime(3000);
  expect(onClose).toHaveBeenCalled(); // Fails intermittently
});

// Solution: Account for animation duration and ensure proper timing
test("auto-dismisses after timeout", () => {
  const onClose = vi.fn();
  render(() => <Notification message="Test" type="info" onClose={onClose} />);
  vi.advanceTimersByTime(3000); // Wait for dismiss timeout
  vi.advanceTimersByTime(300);  // Wait for animation
  expect(onClose).toHaveBeenCalled();
});
```

This error occurred because we weren't accounting for the animation duration in our timer-based tests.

### 2. Hover State Test Failures

Location: `src/components/Notification/__tests__/Notification.test.tsx`

```typescript
// Error: Hover test failing because timer started before hover
test("pauses on hover", async () => {
  const onClose = vi.fn();
  const { container } = render(() => <Notification />);
  vi.advanceTimersByTime(100);
  await fireEvent.mouseEnter(container);
  expect(onClose).not.toHaveBeenCalled(); // Fails
});

// Solution: Hover immediately after render
test("pauses on hover", async () => {
  const onClose = vi.fn();
  const { container } = render(() => <Notification />);
  await fireEvent.mouseEnter(container);
  vi.advanceTimersByTime(3000);
  expect(onClose).not.toHaveBeenCalled();
});
```

This error occurred because the auto-dismiss timer was starting before we could establish the hover state.

### 3. Translation Mock Issues

Location: `src/contexts/__tests__/app.test.tsx`

```typescript
// Error: Translation mock not working consistently
test("notification translates message", () => {
  const app = useAppContext();
  app.t = vi.fn(); // Don't mock at component level
});

// Solution: Mock at module level
vi.mock("~/i18n", () => ({
  getTranslationValue: (key: string) => `translated:${key}`,
}));
```

This error occurred because we were trying to mock translations at the component level instead of the module level.

### 4. Event Timing Issues

Location: `src/components/Notification/__tests__/Notification.test.tsx`

```typescript
// Error: Event timing causing flaky tests
test("handles multiple events", async () => {
  fireEvent.mouseEnter(element);
  fireEvent.mouseLeave(element); // Events too close together
});

// Solution: Use await for events
test("handles multiple events", async () => {
  await fireEvent.mouseEnter(element);
  await fireEvent.mouseLeave(element);
});
```

This error occurred because we weren't properly awaiting event handlers.

### 5. Component State Timing

Location: Various test files

```typescript
// Error: Testing state changes too quickly
test("updates state", () => {
  setSignal("new value");
  expect(element).toHaveText("new value"); // Fails
});

// Solution: Wait for next tick
test("updates state", async () => {
  setSignal("new value");
  await Promise.resolve();
  expect(element).toHaveText("new value");
});
```

This error occurred because we weren't waiting for SolidJS's reactive system to update.

Best Practices to Avoid These Issues:

1. Timer Management:
   - Always account for animation durations
   - Use separate `vi.advanceTimersByTime()` calls for clarity
   - Consider breaking down long timeouts into logical chunks

2. Event Handling:
   - Always `await` fireEvent calls
   - Handle events in sequence, not simultaneously
   - Consider the natural timing of user interactions

3. State Changes:
   - Wait for the next tick after state changes
   - Use `Promise.resolve()` or `queueMicrotask()`
   - Consider batched updates

4. Mocking:
   - Mock at module level, not component level
   - Use `vi.mock()` before tests
   - Be consistent with mock implementations

5. Async Testing:
   - Make tests async when dealing with events
   - Use proper async/await patterns
   - Handle all promises appropriately

6. Component Lifecycle:
   - Consider mounting/unmounting timing
   - Account for cleanup effects
   - Test both mount and update scenarios

Remember to:
- Write deterministic tests
- Avoid timing assumptions
- Mock time-based functions
- Handle async operations properly
- Clean up after each test

### 6. Connection Status Test Failures

Location: `src/hooks/__tests__/useConnectionStatus.test.tsx`

```typescript
// Error 1: Router dependency causing test failures
// The test fails because the app context requires router functionality
test("shows error notification", () => {
  render(() => (
    <Router>  // Error: <A> and 'use' router primitives can only be used inside a Route
      <AppProvider>
        <TestComponent />
      </AppProvider>
    </Router>
  ));
});

// Solution: Mock the router at module level
vi.mock("@solidjs/router", () => ({
  Router: (props: any) => props.children,
  useLocation: () => ({
    pathname: "/test",
    search: "",
    hash: "",
    state: null,
    query: {}
  })
}));

// Error 2: Translation integration causing mismatched expectations
// The test fails because the actual message includes the "translated:" prefix
expect(addNotification).toHaveBeenCalledWith({
  message: "notifications.connectionLost",  // Fails: actual is "translated:notifications.connectionLost"
  type: "error"
});

// Solution: Mock translations and update expectations
vi.mock("~/i18n", () => ({
  getTranslationValue: (translations: any, key: string) => `translated:${key}`,
  translations: {
    en: () => Promise.resolve({
      notifications: {
        connectionLost: "Connection lost",
        connectionRestored: "Connection restored"
      }
    })
  }
}));

expect(addNotification).toHaveBeenCalledWith(
  expect.objectContaining({
    message: "translated:notifications.connectionLost",
    type: "error"
  })
);

// Error 3: Reactive effects not completing
// The test fails because notifications aren't triggered immediately
test("shows notification", () => {
  render(() => <Component />);
  window.dispatchEvent(new Event('offline'));  // Fails: notification not called
  expect(addNotification).toHaveBeenCalled();
});

// Solution: Wait for effects and use async/await
test("shows notification", async () => {
  render(() => <Component />);
  
  // Wait for initial effects
  await Promise.resolve();
  vi.runAllTimers();
  
  window.dispatchEvent(new Event('offline'));
  
  // Wait for event effects
  await Promise.resolve();
  vi.runAllTimers();
  
  expect(addNotification).toHaveBeenCalled();
});
```

These errors highlight several important testing principles:

1. **Module-Level Mocking**
   - Mock external dependencies at the module level
   - Provide complete mock implementations
   - Consider all required functionality

2. **Translation Testing**
   - Mock the translation system consistently
   - Account for translation prefixes/formatting
   - Test with actual translation keys

3. **Reactive Effect Handling**
   - Wait for effects with `Promise.resolve()`
   - Use `vi.runAllTimers()` for timers
   - Make tests async when dealing with effects

4. **Test Environment Setup**
   - Set up browser APIs (navigator.onLine)
   - Mock global objects (__notificationContainer)
   - Clean up after each test

Best practices to avoid these issues:

1. **Dependency Management**
   - Identify all external dependencies
   - Mock dependencies before tests
   - Provide complete mock implementations

2. **Effect Timing**
   - Always handle async operations
   - Wait for effects to complete
   - Use proper cleanup in tests

3. **Browser API Mocking**
   - Mock browser APIs at setup
   - Make properties configurable
   - Reset state between tests

4. **Notification Testing**
   - Mock notification container
   - Verify complete notification objects
   - Check for proper message translation

Remember to:
- Mock all external dependencies
- Handle async operations properly
- Wait for reactive effects
- Clean up between tests
- Match exact notification formats

## Common TypeScript Linting Errors and Solutions

### 1. Object Literal Type Mismatch in Notifications

Location: `src/components/Gallery/Gallery.tsx`

```typescript
// Error: Object literal may only specify known properties
appContext.createNotification({
  message: t("gallery.uploadProgressPercent", { progress }),
  type: "info",
  group: "file-upload",
  progress // Error: 'progress' does not exist in type
});

// Solution: Update the notification type in the app context first
// In src/contexts/app.tsx:
export interface AppContext {
  createNotification: (notification: {
    message: string;
    type: "error" | "success" | "info" | "warning";
    group?: string;
    icon?: "spinner" | "success" | "error" | "info" | "warning";
    progress?: number; // Add the progress property to the type
  }) => void;
}
```

This error occurs when trying to pass properties to a function that aren't defined in its type signature. To avoid this:

1. Always define the complete interface before implementing features
2. Update types in the following order:
   - Base interfaces/types (e.g., `NotificationItem`)
   - Component props (e.g., `NotificationProps`)
   - Context interfaces (e.g., `AppContext`)
   - Implementation code

3. When adding new properties:
   - Make them optional (`?`) if they're not required
   - Update all related interfaces consistently
   - Add appropriate JSDoc comments explaining the property
   - Consider the impact on existing code

4. For notification-specific changes:
   - Update `NotificationItem` in `NotificationContainer.tsx`
   - Update `NotificationProps` in `Notification.tsx`
   - Update the app context interface in `app.tsx`
   - Update any related test files

Example of proper type propagation:

```typescript
// 1. Base type in NotificationContainer.tsx
export interface NotificationItem {
  id: string;
  message: string;
  type: "error" | "success" | "info" | "warning";
  group?: string;
  icon?: "spinner" | "success" | "error" | "info" | "warning";
  progress?: number;
}

// 2. Component props in Notification.tsx
export interface NotificationProps {
  message: string;
  type: "error" | "success" | "info" | "warning";
  group?: string;
  icon?: "spinner" | "success" | "error" | "info" | "warning";
  onClose?: () => void;
  progress?: number;
}

// 3. Context interface in app.tsx
export interface AppContext {
  createNotification: (notification: {
    message: string;
    type: "error" | "success" | "info" | "warning";
    group?: string;
    icon?: "spinner" | "success" | "error" | "info" | "warning";
    progress?: number;
  }) => void;
}
```

Remember to:
- Keep types synchronized across files
- Make new properties optional when possible
- Update all related interfaces at once
- Add appropriate documentation
- Update tests to cover new properties

### 2. Context Type Errors in Tests

Location: `src/components/Gallery/__tests__/DeleteConfirmDialog.test.tsx`

```typescript
// Error: Type error when using AppContext directly as a type
const mockAppContext: AppContext = {  // Error: 'AppContext' refers to a value, but is being used as a type
  // ... mock context properties
};

// Solution: Use Parameters utility type to extract the correct type
const mockAppContext: Parameters<typeof AppContext.Provider>[0]['value'] = {
  // ... mock context properties
};
```

This error occurs because Context objects in React/SolidJS are values, not types. To avoid this:
1. Use TypeScript utility types to extract the correct type
2. Remember that Context objects are values with a Provider property
3. Use `Parameters` to get the type of the Provider's props
4. Access the `value` property type from the Provider's props

### 3. Missing Required Properties in Context Mocks

Location: `src/components/Gallery/__tests__/DeleteConfirmDialog.test.tsx`

```typescript
// Error: Type is missing required properties
const mockAppContext = {  // Error: Type is missing properties 'setdisableNonsense', 'alwaysShowCaptionEditor'
  t: (key: string) => key,
  theme: "light" as Theme
  // ... other properties
};

// Solution: Add all required properties from the context
const mockAppContext = {
  t: (key: string) => key,
  theme: "light" as Theme,
  setdisableNonsense: vi.fn(),
  alwaysShowCaptionEditor: false,
  setAlwaysShowCaptionEditor: vi.fn(),
  // ... other properties
};
```

This error occurs when mocking contexts with required properties. To avoid this:
1. Check the context interface for all required properties
2. Mock all required properties, even if unused in the test
3. Use `vi.fn()` for function properties
4. Keep mock values simple but valid
5. Consider creating a helper function to generate mock contexts

### 4. Translation Parameter Type Mismatches

Location: `src/components/Gallery/__tests__/DeleteConfirmDialog.test.tsx`

```typescript
// Error: Parameter 'params' implicitly has 'any' type
const mockAppContext = {
  t: (key: string, params) => {  // Error: Parameter 'params' implicitly has an 'any' type
    return translations[key];
  }
};

// Solution: Properly type the translation function parameters
const mockAppContext = {
  t: (key: string, params?: Record<string, unknown>) => {
    const translations: Record<string, string> = {
      'gallery.confirmMultiDelete': `Delete ${params?.count} items (${params?.folders} folders, ${params?.images} images)?`
    };
    return translations[key] || key;
  }
};
```

This error occurs when translation functions don't properly type their parameters. To avoid this:
1. Always specify parameter types explicitly
2. Use optional parameters with `?` when appropriate
3. Use `Record<string, unknown>` for generic object parameters
4. Consider creating type definitions for translation parameters
5. Document expected parameter shapes in comments

Best practices to avoid these TypeScript errors:

1. **Context Typing**
   - Never use Context objects directly as types
   - Use TypeScript utility types to extract proper types
   - Keep type definitions separate from implementations
   - Document type structures in comments

2. **Mock Completeness**
   - Always check interface definitions for required properties
   - Create helper functions for generating complete mocks
   - Use TypeScript to enforce mock completeness
   - Keep mock implementations minimal but valid

3. **Translation Types**
   - Define explicit types for translation parameters
   - Use TypeScript template literal types when applicable
   - Document parameter shapes and requirements
   - Consider creating type definitions for common translation patterns

Remember to:
- Check interface definitions thoroughly
- Use TypeScript utility types appropriately
- Keep mocks minimal but complete
- Document type structures and requirements
- Use proper typing for translation functions
