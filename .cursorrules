# The `yipyap` Manifesto

---

The frontend of yipyap is built with SolidJS, a reactive JavaScript framework that emphasizes fine-grained reactivity and performance, using Vite as the build tool for fast development and optimized production builds. The application follows a component-based architecture with a central app context managing global state. The main entry point is `/src/main.tsx`, which sets up routing and the app context, while the core application logic resides in `/src/contexts/app.tsx`.

Components are organized in feature-based directories under `/src/components`, each with its own CSS module for styling and `__tests__` directory for component-specific tests. Global styles are defined in `/src/styles.css`, while theme-specific styles are in `/src/themes.css`. The application uses CSS custom properties extensively for theming and maintains a consistent visual hierarchy through shared spacing and color variables.

The backend integration is handled through a well-defined API interface, with endpoints for file operations, metadata management, and caption generation. The frontend communicates with these endpoints using typed fetch requests, with proper error handling and loading states. The API interface is defined in TypeScript types shared between the frontend and backend, ensuring type safety across the full stack.

The application includes a comprehensive error handling system with a global error boundary and component-level error states. Errors are displayed through a notification system that supports different severity levels (error, warning, info, success) and can be configured for automatic dismissal. Loading states are managed through SolidJS's resource system, providing a consistent loading experience across the application.

The application's state management is handled through a combination of SolidJS's fine-grained reactivity system and context providers. The app context (`/src/contexts/app.tsx`) manages global settings and theme state, while feature-specific contexts (like the gallery context) handle domain-specific state. All state changes are properly typed and can be persisted to localStorage when appropriate.

## The Gallery System

The gallery system is the heart of the application, featuring a sophisticated image viewer with advanced features for image display, navigation, and metadata management. The system is built around several key components:

### Image Viewer Core (`ImageView` Component)

- **Smooth Zooming**: Implements a sophisticated zoom system with:
  - Gradual and smooth zoom transitions (0.001 zoom factor for precision)
  - Cursor-relative zooming that maintains focus point
  - Scale limits (1x to 5x) with smooth interpolation
  - Double-click to reset zoom
  - Zoom level indicator showing current magnification

- **Advanced Panning**:
  - Cursor-aware panning when zoomed
  - Smooth transitions with cubic-bezier easing
  - Grab/grabbing cursor states
  - Edge detection to prevent over-panning
  - Hardware-accelerated transforms for performance

- **Minimap Navigation**:
  - Real-time viewport tracking
  - Interactive navigation by clicking
  - Smooth viewport updates
  - Theme-aware styling with semi-transparent overlay
  - Automatic show/hide based on zoom state
  - Configurable through app settings (`enableMinimap`)

### Image Loading and Display

- **Progressive Loading**:
  - Immediate thumbnail display while loading full preview
  - Smooth opacity transitions between thumbnail and preview
  - Priority-based image loading system
  - Automatic resource cleanup
  - Loading state indicators

- **Performance Optimizations**:
  - Hardware-accelerated transforms
  - Will-change hints for smooth animations
  - Efficient resize handling with ResizeObserver
  - Memory-conscious image unloading
  - Touch action handling for mobile devices

### Tagging System

- **Advanced Color Generation**:
  - OKLCH color space for perceptually uniform colors
  - Theme-aware color generation with specific rules per theme:
    - Dark theme: Low lightness (25%), subtle chroma
    - Light theme: High lightness (85%), subtle chroma
    - Gray theme: Variable lightness, zero chroma
    - Themed variants (banana, strawberry, peanut, christmas, halloween)
  - Deterministic color generation for consistent tag colors
  - Automatic contrast adjustment for text readability

- **Interactive Tag Management**:
  - Keyboard navigation between tags
  - Double-tap detection for quick editing
  - Smooth animations for tag creation/deletion
  - Batch operations support
  - Theme-specific animations and hover effects
  - RTL language support

### Caption Generation

- **Multiple Model Support**:
  - JTP2 and WDv3 model integration
  - Progress tracking with notifications
  - Error handling with user feedback
  - Automatic caption type detection
  - Real-time caption updates

### Accessibility and UX

- **Keyboard Support**:
  - Full keyboard navigation
  - Accessible controls with ARIA labels
  - Focus management
  - Screen reader support

- **Visual Feedback**:
  - Loading indicators
  - Progress notifications
  - Error states
  - Theme-aware animations
  - High contrast support

### Theme Integration

- **Comprehensive Theming**:
  - Theme-specific tag colors and animations
  - Dark/light mode support
  - Special theme variants with unique effects
  - Consistent styling across components
  - Dynamic theme switching
  - RTL layout support

The system is built with performance and extensibility in mind, using SolidJS's fine-grained reactivity for efficient updates and a modular architecture that allows for easy addition of new features and themes.

## Theming System

For detailed information about the theming system, including theme variables, style changes, and best practices, please refer to the [Theming Documentation](docs/theming.md) when writing CSS.

Maintain consistency with existing code by following established naming conventions and reusing components and styles where appropriate. When writing CSS, ensure compatibility with the global styles defined in `/src/styles.css`.

Theme specific styles are in the `/src/themes.css` file.

There is no `App.tsx` file, do not create it, the root component is in the `/src/main.tsx` file, `/src/contexts/app.tsx` is the app context which is the global state of the app.

Think step-by-step and write code that is easy to understand and maintain.

## Translation System

For detailed information about the translation system, including type definitions, language support, and best practices, please refer to the [Translation Documentation](docs/translations.md).

## Making Style Changes

For detailed information about making style changes to the application, please refer to the [Theming Documentation](docs/theming.md).

For guidelines on using backdrop filters in the application, including best practices, please refer to the [Backdrop Filter Documentation](docs/backdrop-filter.md).

For information about implementing smooth transitions for overlay elements like modals and popovers, please refer to the [Overlay Transitions Documentation](docs/overlay-transitions.md).

## Writing Tests

For documentation about writing tests, including test environment setup, patterns, and best practices, please refer to the [Testing Documentation](docs/testing.md).

## Notifications

For detailed information about the notification system, including architecture, usage, features, and best practices, please refer to the [Notifications Documentation](docs/notifications.md).

## Common TypeScript Linting Errors and Solutions

For information about common TypeScript linting errors and their solutions, please refer to the [Linting Documentation](docs/linting.md).

## Select Element Labeling

For detailed information about ARIA labeling best practices and accessibility requirements, please refer to the [ARIA Labeling Guide](docs/aria-labels.md).

## Adding New Settings

For detailed information about adding new settings to the application, including step-by-step instructions and best practices, please refer to the [Settings Documentation](docs/settings.md).

## Reading and Writing Documentation

Always read the whole documentation on the related topic before writing code.

Instead of using lists while writing documentation, use paragraphs. Only use lists when listing files and do not include the file size in the list.

## Composables in SolidJS

The application uses composables for reusable reactive logic, following SolidJS's composition pattern. All composables must be placed in the `/src/composables` directory. Never create a `hooks` directory or use the term "hooks" - this terminology is specific to React and does not align with SolidJS's mental model.

Composables are functions that encapsulate reactive logic and return signals, memos, or other reactive primitives. They should be named with the `use` prefix to indicate their role as composition functions. Each composable should focus on a specific concern, such as state management, event handling, or data fetching.

The composables directory structure reflects the feature-based organization of the application. For example, gallery-related composables like `useGalleryScroll`, `useGalleryUI`, and `useGalleryEffects` are grouped together to maintain clear boundaries and dependencies.

When creating new composables, ensure they:
- Have a clear, single responsibility
- Return only the necessary reactive primitives
- Clean up resources when no longer needed
- Are well-typed with TypeScript
- Include proper documentation and usage examples
